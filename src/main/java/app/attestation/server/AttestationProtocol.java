package app.attestation.server;

import app.attestation.server.attestation.AttestationApplicationId;
import app.attestation.server.attestation.AttestationApplicationId.AttestationPackageInfo;
import app.attestation.server.attestation.AuthorizationList;
import app.attestation.server.attestation.ParsedAttestationRecord;
import app.attestation.server.attestation.RootOfTrust;
import com.almworks.sqlite4java.SQLiteConnection;
import com.almworks.sqlite4java.SQLiteException;
import com.almworks.sqlite4java.SQLiteStatement;
import com.github.benmanes.caffeine.cache.Cache;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.hash.HashFunction;
import com.google.common.hash.Hashing;
import com.google.common.io.BaseEncoding;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.ByteBuffer;
import java.security.GeneralSecurityException;
import java.security.PublicKey;
import java.security.SecureRandom;
import java.security.Signature;
import java.security.cert.Certificate;
import java.security.cert.CertificateEncodingException;
import java.security.cert.CertificateException;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.logging.Logger;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.DeflaterOutputStream;
import java.util.zip.Inflater;

class AttestationProtocol {
    private static final Logger logger = Logger.getLogger(AttestationProtocol.class.getName());

    static final int RANDOM_TOKEN_LENGTH = 32;
    private static final String SIGNATURE_ALGORITHM = "SHA256WithECDSA";
    private static final HashFunction FINGERPRINT_HASH_FUNCTION = Hashing.sha256();
    private static final int FINGERPRINT_LENGTH = FINGERPRINT_HASH_FUNCTION.bits() / 8;

    // Challenge message:
    //
    // byte maxVersion = PROTOCOL_VERSION
    // byte[] challenge index (length: RANDOM_TOKEN_LENGTH)
    // byte[] challenge (length: RANDOM_TOKEN_LENGTH)
    //
    // The challenge index is randomly generated by Auditor and used for all future challenge
    // messages from that Auditor. It's used on the Auditee as an index to choose the correct
    // persistent key to satisfy the Auditor, rather than only supporting pairing with one. In
    // theory, the Auditor could authenticate to the Auditee, but this app already provides a
    // better way to do that by doing the same process in reverse for a supported device.
    //
    // The challenge is randomly generated by the Auditor and serves the security function of
    // enforcing that the results are fresh. It's returned inside the attestation certificate
    // which has a signature from the device's provisioned key (not usable by the OS) and the
    // outer signature from the hardware-backed key generated for the initial pairing.
    //
    // Attestation message:
    //
    // For backwards compatibility the Auditor device sends its maximum supported version, and
    // the Auditee uses the highest version it supports.
    //
    // Compression is done with raw DEFLATE (no zlib wrapper) with a preset dictionary generated from
    // sample certificates.
    //
    // signed message {
    // byte version = min(maxVersion, PROTOCOL_VERSION)
    // short compressedChainLength
    // byte[] compressedChain { [short encodedCertificateLength, byte[] encodedCertificate] }
    // byte[] fingerprint (length: FINGERPRINT_LENGTH)
    // int osEnforcedFlags
    // int autoRebootSeconds (-1 for unknown)
    // byte portSecurityMode (-1 for unknown)
    // byte userCount (-1 for unknown)
    // byte oemUnlockAllowed (-1 for unknown)
    // }
    // byte[] signature (rest of message)
    //
    // Protocol version changes:
    //
    // 6: autoRebootSeconds added
    // 6: portSecurityMode added
    // 6: userCount added
    // 6: oemUnlockAllowed added
    //
    // n/a
    //
    // For each audit, the Auditee generates a fresh hardware-backed key with key attestation
    // using the provided challenge. It reports back the certificate chain to be verified by the
    // Auditor. The public key certificate of the generated key is signed by a key provisioned on
    // the device (not usable by the OS) chaining up to an intermediate and the Google root. The
    // certificate contains the key attestation metadata including the important fields with the
    // lock state, verified boot state, the verified boot public key fingerprint and the OS
    // version / patch level:
    //
    // https://developer.android.com/training/articles/security-key-attestation.html#certificate_schema
    //
    // The Auditee keeps the first hardware-backed key generated for a challenge index and uses it
    // to sign all future attestations. The fingerprint of the persistent key is included in the
    // attestation message for the Auditor to find the corresponding pinning data. Other keys are
    // never actually used, only generated for fresh key attestation data.
    //
    // The OS can use the persistent generated hardware-backed key for signing but cannot obtain
    // the private key. The key isn't be usable if verified boot fails or the OS is downgraded and
    // the keys are protected against replay attacks via the Replay Protected Memory Block.
    // Devices launching with Android P or later can provide a StrongBox Keymaster to support
    // storing the keys in a dedicated hardware security module to substantially reduce the attack
    // surface for obtaining the keys. StrongBox is paired with the TEE and the TEE corroborates
    // the validity of the keys and attestation. The Pixel 3 and 3 XL are the first devices with a
    // StrongBox implementation via the Titan M security chip.
    //
    // https://android-developers.googleblog.com/2018/10/building-titan-better-security-through.html
    //
    // The attestation message also includes osEnforcedFlags with data obtained at the OS level,
    // which is vulnerable to tampering by an attacker with control over the OS. However, the OS
    // did get verified by verified boot so without a verified boot bypass they would need to keep
    // exploiting it after booting. The bootloader / TEE verified OS version / OS patch level are
    // a useful mitigation as they reveal that the OS isn't upgraded even if an attacker has root.
    //
    // The Auditor saves the initial certificate chain, using the initial certificate to verify
    // the outer signature and the rest of the chain for pinning the expected chain. It enforces
    // downgrade protection for the OS version/patch (bootloader/TEE enforced) and app version (OS
    // enforced) by keeping them updated.
    static final byte PROTOCOL_VERSION = 6;
    private static final byte PROTOCOL_VERSION_MINIMUM = 5;
    // can become longer in the future, but this is the minimum length
    private static final byte CHALLENGE_MESSAGE_LENGTH = 1 + RANDOM_TOKEN_LENGTH * 2;
    private static final int MAX_ENCODED_CHAIN_LENGTH = 5000;
    static final int MAX_MESSAGE_SIZE = 2953;

    private static final int OS_ENFORCED_FLAGS_NONE = 0;
    private static final int OS_ENFORCED_FLAGS_USER_PROFILE_SECURE = 1;
    private static final int OS_ENFORCED_FLAGS_ACCESSIBILITY = 1 << 1;
    private static final int OS_ENFORCED_FLAGS_DEVICE_ADMIN = 1 << 2;
    private static final int OS_ENFORCED_FLAGS_ADB_ENABLED = 1 << 3;
    private static final int OS_ENFORCED_FLAGS_ADD_USERS_WHEN_LOCKED = 1 << 4;
    private static final int OS_ENFORCED_FLAGS_ENROLLED_BIOMETRICS = 1 << 5;
    private static final int OS_ENFORCED_FLAGS_DENY_NEW_USB = 1 << 6; // obsolete since version 76
    private static final int OS_ENFORCED_FLAGS_DEVICE_ADMIN_NON_SYSTEM = 1 << 7;
    private static final int OS_ENFORCED_FLAGS_OEM_UNLOCK_ALLOWED = 1 << 8; // obsolete since version 89
    private static final int OS_ENFORCED_FLAGS_SYSTEM_USER = 1 << 9;
    private static final int OS_ENFORCED_FLAGS_ALL =
            OS_ENFORCED_FLAGS_USER_PROFILE_SECURE |
            OS_ENFORCED_FLAGS_ACCESSIBILITY |
            OS_ENFORCED_FLAGS_DEVICE_ADMIN |
            OS_ENFORCED_FLAGS_ADB_ENABLED |
            OS_ENFORCED_FLAGS_ADD_USERS_WHEN_LOCKED |
            OS_ENFORCED_FLAGS_ENROLLED_BIOMETRICS |
            OS_ENFORCED_FLAGS_DENY_NEW_USB |
            OS_ENFORCED_FLAGS_DEVICE_ADMIN_NON_SYSTEM |
            OS_ENFORCED_FLAGS_OEM_UNLOCK_ALLOWED |
            OS_ENFORCED_FLAGS_SYSTEM_USER;

    private static final String AUDITOR_APP_PACKAGE_NAME_RELEASE = "app.attestation.auditor";
    private static final String AUDITOR_APP_PACKAGE_NAME_PLAY = "app.attestation.auditor.play";
    private static final String AUDITOR_APP_PACKAGE_NAME_DEBUG = "app.attestation.auditor.debug";
    private static final String AUDITOR_APP_SIGNATURE_DIGEST_RELEASE =
            "990E04F0864B19F14F84E0E432F7A393F297AB105A22C1E1B10B442A4A62C42C";
    private static final String AUDITOR_APP_SIGNATURE_DIGEST_PLAY =
            "075335BD7B54C965222B5284D2A1FDEF1198AE45EC7B09A4934287A0E3A243C7";
    private static final String AUDITOR_APP_SIGNATURE_DIGEST_DEBUG =
            "17727D8B61D55A864936B1A7B4A2554A15151F32EBCF44CDAA6E6C3258231890";
    private static final byte AUDITOR_APP_VARIANT_RELEASE = 0;
    private static final byte AUDITOR_APP_VARIANT_PLAY = 1;
    private static final byte AUDITOR_APP_VARIANT_DEBUG = 2;

    private static final int AUDITOR_APP_MINIMUM_VERSION = 73;
    private static final int OS_VERSION_MINIMUM = 130000;
    private static final int OS_PATCH_LEVEL_MINIMUM = 202208;
    private static final int VENDOR_PATCH_LEVEL_MINIMUM = 20220805;
    private static final int BOOT_PATCH_LEVEL_MINIMUM = 20220805;

    private static final String DEVICE_PIXEL_4_GENERIC = "Google Pixel 4 / Pixel 4 XL";
    private static final String DEVICE_PIXEL_4 = "Google Pixel 4";
    private static final String DEVICE_PIXEL_4_XL = "Google Pixel 4 XL";
    private static final String DEVICE_PIXEL_4A = "Google Pixel 4a";
    private static final String DEVICE_PIXEL_4A_5G = "Google Pixel 4a (5G)";
    private static final String DEVICE_PIXEL_5 = "Google Pixel 5";
    private static final String DEVICE_PIXEL_5_GENERIC = "Google Pixel 4a (5G) / Pixel 5";
    private static final String DEVICE_PIXEL_5A = "Google Pixel 5a";
    private static final String DEVICE_PIXEL_6 = "Google Pixel 6";
    private static final String DEVICE_PIXEL_6_PRO = "Google Pixel 6 Pro";
    private static final String DEVICE_PIXEL_6A = "Google Pixel 6a";
    private static final String DEVICE_PIXEL_7 = "Google Pixel 7";
    private static final String DEVICE_PIXEL_7_PRO = "Google Pixel 7 Pro";
    private static final String DEVICE_PIXEL_7A = "Google Pixel 7a";
    private static final String DEVICE_PIXEL_TABLET = "Google Pixel Tablet";
    private static final String DEVICE_PIXEL_FOLD = "Google Pixel Fold";
    private static final String DEVICE_PIXEL_8 = "Google Pixel 8";
    private static final String DEVICE_PIXEL_8_PRO = "Google Pixel 8 Pro";
    private static final String DEVICE_PIXEL_8A = "Google Pixel 8a";
    private static final String DEVICE_PIXEL_9 = "Google Pixel 9";
    private static final String DEVICE_PIXEL_9_PRO = "Google Pixel 9 Pro";
    private static final String DEVICE_PIXEL_9_PRO_XL = "Google Pixel 9 Pro XL";
    private static final String DEVICE_PIXEL_9_PRO_FOLD = "Google Pixel 9 Pro Fold";
    private static final String DEVICE_PIXEL_9A = "Google Pixel 9a";

    private static final String OS_STOCK = "Stock";
    private static final String OS_GRAPHENE = "GrapheneOS";

    public record DeviceInfo(String name, int attestationVersion, int keymasterVersion,
            // API for detecting this was replaced in keymaster v3 but the new one isn't used yet
            boolean rollbackResistant,
            boolean enforceStrongBox, String osName) {

        boolean hasPogoPins() {
            return DEVICE_PIXEL_TABLET.equals(name);
        }
    }

    static final ImmutableMap<String, DeviceInfo> fingerprintsCustomOS = ImmutableMap
            .<String, DeviceInfo>builder()
            // GrapheneOS
            .put("80EF268700EE42686F779A47B4A155FE1FFC2EEDF836B4803CAAB8FA61439746",
                    new DeviceInfo(DEVICE_PIXEL_4, 3, 4, false, true, OS_GRAPHENE))
            .put("3F15FDCB82847FED97427CE00563B8F9FF34627070DE5FDB17ACA7849AB98CC8",
                    new DeviceInfo(DEVICE_PIXEL_4_XL, 3, 4, false, true, OS_GRAPHENE))
            .put("9F2454A1657B1B5AD7F2336B39A2611F7A40B2E0DDFD0D6553A359605928DF29",
                    new DeviceInfo(DEVICE_PIXEL_4A, 3, 4, false, true, OS_GRAPHENE))
            .put("DCEC2D053D3EC4F1C9BE414AA07E4D7D7CBD12040AD2F8831C994A83A0536866",
                    new DeviceInfo(DEVICE_PIXEL_4A_5G, 3, 4, false, true, OS_GRAPHENE))
            .put("36A99EAB7907E4FB12A70E3C41C456BCBE46C13413FBFE2436ADEE2B2B61120F",
                    new DeviceInfo(DEVICE_PIXEL_5, 3, 4, false, true, OS_GRAPHENE))
            .put("0ABDDEDA03B6CE10548C95E0BEA196FAA539866F929BCDF7ECA84B4203952514",
                    new DeviceInfo(DEVICE_PIXEL_5A, 3, 4, false, true, OS_GRAPHENE))
            .put("F0A890375D1405E62EBFD87E8D3F475F948EF031BBF9DDD516D5F600A23677E8",
                    new DeviceInfo(DEVICE_PIXEL_6, 100, 100, false, true, OS_GRAPHENE))
            .put("439B76524D94C40652CE1BF0D8243773C634D2F99BA3160D8D02AA5E29FF925C",
                    new DeviceInfo(DEVICE_PIXEL_6_PRO, 100, 100, false, true, OS_GRAPHENE))
            .put("08C860350A9600692D10C8512F7B8E80707757468E8FBFEEA2A870C0A83D6031",
                    new DeviceInfo(DEVICE_PIXEL_6A, 100, 100, false, true, OS_GRAPHENE))
            .put("3EFE5392BE3AC38AFB894D13DE639E521675E62571A8A9B3EF9FC8C44FD17FA1",
                    new DeviceInfo(DEVICE_PIXEL_7, 200, 200, false, true, OS_GRAPHENE))
            .put("BC1C0DD95664604382BB888412026422742EB333071EA0B2D19036217D49182F",
                    new DeviceInfo(DEVICE_PIXEL_7_PRO, 200, 200, false, true, OS_GRAPHENE))
            .put("508D75DEA10C5CBC3E7632260FC0B59F6055A8A49DD84E693B6D8899EDBB01E4",
                    new DeviceInfo(DEVICE_PIXEL_7A, 200, 200, false, true, OS_GRAPHENE))
            .put("94DF136E6C6AA08DC26580AF46F36419B5F9BAF46039DB076F5295B91AAFF230",
                    new DeviceInfo(DEVICE_PIXEL_TABLET, 200, 200, false, true, OS_GRAPHENE))
            .put("EE0C9DFEF6F55A878538B0DBF7E78E3BC3F1A13C8C44839B095FE26DD5FE2842",
                    new DeviceInfo(DEVICE_PIXEL_FOLD, 200, 200, false, true, OS_GRAPHENE))
            .put("CD7479653AA88208F9F03034810EF9B7B0AF8A9D41E2000E458AC403A2ACB233",
                    new DeviceInfo(DEVICE_PIXEL_8, 300, 300, false, true, OS_GRAPHENE))
            .put("896DB2D09D84E1D6BB747002B8A114950B946E5825772A9D48BA7EB01D118C1C",
                    new DeviceInfo(DEVICE_PIXEL_8_PRO, 300, 300, false, true, OS_GRAPHENE))
            .put("096B8BD6D44527A24AC1564B308839F67E78202185CBFF9CFDCB10E63250BC5E",
                    new DeviceInfo(DEVICE_PIXEL_8A, 300, 300, false, true, OS_GRAPHENE))
            .put("9E6A8F3E0D761A780179F93ACD5721BA1AB7C8C537C7761073C0A754B0E932DE",
                    new DeviceInfo(DEVICE_PIXEL_9, 300, 300, false, true, OS_GRAPHENE))
            .put("F729CAB861DA1B83FDFAB402FC9480758F2AE78EE0B61C1F2137DD1AB7076E86",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO, 300, 300, false, true, OS_GRAPHENE))
            .put("55D3C2323DB91BB91F20D38D015E85112D038F6B6B5738FE352C1A80DBA57023",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_XL, 300, 300, false, true, OS_GRAPHENE))
            .put("AF4D2C6E62BE0FEC54F0271B9776FF061DD8392D9F51CF6AB1551D346679E24C",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_FOLD, 300, 300, false, true, OS_GRAPHENE))
            .put("0508DE44EE00BFB49ECE32C418AF1896391ABDE0F05B64F41BC9A2DFB589445B",
                    new DeviceInfo(DEVICE_PIXEL_9A, 300, 300, false, true, OS_GRAPHENE))
            .build();
    static final ImmutableMap<String, DeviceInfo> fingerprintsStock = ImmutableMap
            .<String, DeviceInfo>builder()
            .put("AE6316B4753C61F5855B95B9B98484AF784F2E83648D0FCC8107FCA752CAEA34",
                    new DeviceInfo(DEVICE_PIXEL_4_GENERIC, 3, 4, false, true, OS_STOCK))
            .put("879CD3F18EA76E244D4D4AC3BCB9C337C13B4667190B19035AFE2536550050F1",
                    new DeviceInfo(DEVICE_PIXEL_4A, 3, 4, false, true, OS_STOCK))
            .put("88265D85BA9E1E2F6036A259D880D2741031ACA445840137395B6D541C0FC7FC",
                    new DeviceInfo(DEVICE_PIXEL_5_GENERIC, 3, 4, false, true, OS_STOCK))
            .put("1DD694CE00BF131AD61CEB576B7DCC41CF7F9B2C418F4C12B2B8F3E9A1EA911D",
                    new DeviceInfo(DEVICE_PIXEL_5A, 3, 4, false, true, OS_STOCK))
            .put("0F6E75C80183B5DEC074B0054D4271E99389EBE4B136B0819DE1F150BA0FF9D7",
                    new DeviceInfo(DEVICE_PIXEL_6, 100, 100, false, true, OS_STOCK))
            .put("42ED1BCA352FABD428F34E8FCEE62776F4CB2C66E06F82E5A59FF4495267BFC2",
                    new DeviceInfo(DEVICE_PIXEL_6_PRO, 100, 100, false, true, OS_STOCK))
            .put("9AC4174153D45E4545B0F49E22FE63273999B6AC1CB6949C3A9F03EC8807EEE9",
                    new DeviceInfo(DEVICE_PIXEL_6A, 100, 100, false, true, OS_STOCK))
            .put("8B2C4CD539F5075E8E7CF212ADB3DB0413FBD77D321199C73D5A473C51F2E10D",
                    new DeviceInfo(DEVICE_PIXEL_7, 200, 200, false, true, OS_STOCK))
            .put("26AC4C60BEB1E378357CAD0C3061347AF8DF6FBABBB0D8CEA2445855EE01E368",
                    new DeviceInfo(DEVICE_PIXEL_7_PRO, 200, 200, false, true, OS_STOCK))
            .put("003F1ADE9D476E612B00F2983E6AD7DCD15E6A80CC2DBB008DA7D6839ED73A8F",
                    new DeviceInfo(DEVICE_PIXEL_7A, 200, 200, false, true, OS_STOCK))
            .put("C72E569827EC2E19A1073D927E3B6A1C6C8322DA795D5CE44BF3B95031B37C0A",
                    new DeviceInfo(DEVICE_PIXEL_TABLET, 200, 200, false, true, OS_STOCK))
            .put("3BBD4712D8714812E762D3FB6D2D5724800C3342B1835CDBC1D3634AE59D646E",
                    new DeviceInfo(DEVICE_PIXEL_FOLD, 200, 200, false, true, OS_STOCK))
            .put("64DEF0828FF5D3EAC65C3F5CEF46C1D855FE0A5D8525E90FB94FC3DBA9988C87",
                    new DeviceInfo(DEVICE_PIXEL_8, 300, 300, false, true, OS_STOCK))
            .put("E5362DDF4676E8AA134DB520749BCB1F44FE6556F5E7BFAB130CB6343476FC15",
                    new DeviceInfo(DEVICE_PIXEL_8_PRO, 300, 300, false, true, OS_STOCK))
            .put("9DE25FB02BB5530D44149D148437C82E267E557322530AA6F03B0AC2E92931DA",
                    new DeviceInfo(DEVICE_PIXEL_8A, 300, 300, false, true, OS_STOCK))
            .put("ACB5A4DD184E2C44CFA6A53D2D5C5E8674C9498A59F8AE8019942AC1FCEB1E6C",
                    new DeviceInfo(DEVICE_PIXEL_9, 300, 300, false, true, OS_STOCK))
            .put("06035F636BDB7F299A94B51C7D5645A913551327FFC5452B00C5830476D3208E",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO, 300, 300, false, true, OS_STOCK))
            .put("D05975CFD778082E3D1623C91419F6D8634E579A786592118CCEA057537579B7",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_XL, 300, 300, false, true, OS_STOCK))
            .put("800E9093D29614F5BC3FC76A0E819BA0A5C0C94A7D6A17C53E7D017D346B7172",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_FOLD, 300, 300, false, true, OS_STOCK))
            .put("3327AF62D84AB897AF2523A16DCB5801E60C5D5B97F41CA1BD099C4784F7B743",
                    new DeviceInfo(DEVICE_PIXEL_9A, 300, 300, false, true, OS_STOCK))
            .build();

    static final ImmutableMap<String, DeviceInfo> fingerprintsStrongBoxCustomOS = ImmutableMap
            .<String, DeviceInfo>builder()
            // GrapheneOS
            .put("80EF268700EE42686F779A47B4A155FE1FFC2EEDF836B4803CAAB8FA61439746",
                    new DeviceInfo(DEVICE_PIXEL_4, 3, 4, false, true, OS_GRAPHENE))
            .put("3F15FDCB82847FED97427CE00563B8F9FF34627070DE5FDB17ACA7849AB98CC8",
                    new DeviceInfo(DEVICE_PIXEL_4_XL, 3, 4, false, true, OS_GRAPHENE))
            .put("9F2454A1657B1B5AD7F2336B39A2611F7A40B2E0DDFD0D6553A359605928DF29",
                    new DeviceInfo(DEVICE_PIXEL_4A, 3, 4, false, true, OS_GRAPHENE))
            .put("DCEC2D053D3EC4F1C9BE414AA07E4D7D7CBD12040AD2F8831C994A83A0536866",
                    new DeviceInfo(DEVICE_PIXEL_4A_5G, 4, 41, false, true, OS_GRAPHENE))
            .put("36A99EAB7907E4FB12A70E3C41C456BCBE46C13413FBFE2436ADEE2B2B61120F",
                    new DeviceInfo(DEVICE_PIXEL_5, 4, 41, false, true, OS_GRAPHENE))
            .put("0ABDDEDA03B6CE10548C95E0BEA196FAA539866F929BCDF7ECA84B4203952514",
                    new DeviceInfo(DEVICE_PIXEL_5A, 4, 41, false, true, OS_GRAPHENE))
            .put("F0A890375D1405E62EBFD87E8D3F475F948EF031BBF9DDD516D5F600A23677E8",
                    new DeviceInfo(DEVICE_PIXEL_6, 100, 100, false, true, OS_GRAPHENE))
            .put("439B76524D94C40652CE1BF0D8243773C634D2F99BA3160D8D02AA5E29FF925C",
                    new DeviceInfo(DEVICE_PIXEL_6_PRO, 100, 100, false, true, OS_GRAPHENE))
            .put("08C860350A9600692D10C8512F7B8E80707757468E8FBFEEA2A870C0A83D6031",
                    new DeviceInfo(DEVICE_PIXEL_6A, 100, 100, false, true, OS_GRAPHENE))
            .put("3EFE5392BE3AC38AFB894D13DE639E521675E62571A8A9B3EF9FC8C44FD17FA1",
                    new DeviceInfo(DEVICE_PIXEL_7, 100, 100, false, true, OS_GRAPHENE))
            .put("BC1C0DD95664604382BB888412026422742EB333071EA0B2D19036217D49182F",
                    new DeviceInfo(DEVICE_PIXEL_7_PRO, 100, 100, false, true, OS_GRAPHENE))
            .put("508D75DEA10C5CBC3E7632260FC0B59F6055A8A49DD84E693B6D8899EDBB01E4",
                    new DeviceInfo(DEVICE_PIXEL_7A, 100, 100, false, true, OS_GRAPHENE))
            .put("94DF136E6C6AA08DC26580AF46F36419B5F9BAF46039DB076F5295B91AAFF230",
                    new DeviceInfo(DEVICE_PIXEL_TABLET, 100, 100, false, true, OS_GRAPHENE))
            .put("EE0C9DFEF6F55A878538B0DBF7E78E3BC3F1A13C8C44839B095FE26DD5FE2842",
                    new DeviceInfo(DEVICE_PIXEL_FOLD, 100, 100, false, true, OS_GRAPHENE))
            .put("CD7479653AA88208F9F03034810EF9B7B0AF8A9D41E2000E458AC403A2ACB233",
                    new DeviceInfo(DEVICE_PIXEL_8, 300, 300, false, true, OS_GRAPHENE))
            .put("896DB2D09D84E1D6BB747002B8A114950B946E5825772A9D48BA7EB01D118C1C",
                    new DeviceInfo(DEVICE_PIXEL_8_PRO, 300, 300, false, true, OS_GRAPHENE))
            .put("096B8BD6D44527A24AC1564B308839F67E78202185CBFF9CFDCB10E63250BC5E",
                    new DeviceInfo(DEVICE_PIXEL_8A, 300, 300, false, true, OS_GRAPHENE))
            .put("9E6A8F3E0D761A780179F93ACD5721BA1AB7C8C537C7761073C0A754B0E932DE",
                    new DeviceInfo(DEVICE_PIXEL_9, 300, 300, false, true, OS_GRAPHENE))
            .put("F729CAB861DA1B83FDFAB402FC9480758F2AE78EE0B61C1F2137DD1AB7076E86",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO, 300, 300, false, true, OS_GRAPHENE))
            .put("55D3C2323DB91BB91F20D38D015E85112D038F6B6B5738FE352C1A80DBA57023",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_XL, 300, 300, false, true, OS_GRAPHENE))
            .put("AF4D2C6E62BE0FEC54F0271B9776FF061DD8392D9F51CF6AB1551D346679E24C",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_FOLD, 300, 300, false, true, OS_GRAPHENE))
            .put("0508DE44EE00BFB49ECE32C418AF1896391ABDE0F05B64F41BC9A2DFB589445B",
                    new DeviceInfo(DEVICE_PIXEL_9A, 300, 300, false, true, OS_GRAPHENE))
            .build();
    static final ImmutableMap<String, DeviceInfo> fingerprintsStrongBoxStock = ImmutableMap
            .<String, DeviceInfo>builder()
            .put("AE6316B4753C61F5855B95B9B98484AF784F2E83648D0FCC8107FCA752CAEA34",
                    new DeviceInfo(DEVICE_PIXEL_4_GENERIC, 3, 4, false, true, OS_STOCK))
            .put("879CD3F18EA76E244D4D4AC3BCB9C337C13B4667190B19035AFE2536550050F1",
                    new DeviceInfo(DEVICE_PIXEL_4A, 3, 4, false, true, OS_STOCK))
            .put("88265D85BA9E1E2F6036A259D880D2741031ACA445840137395B6D541C0FC7FC",
                    new DeviceInfo(DEVICE_PIXEL_5_GENERIC, 4, 41, false, true, OS_STOCK))
            .put("1DD694CE00BF131AD61CEB576B7DCC41CF7F9B2C418F4C12B2B8F3E9A1EA911D",
                    new DeviceInfo(DEVICE_PIXEL_5A, 4, 41, false, true, OS_STOCK))
            .put("0F6E75C80183B5DEC074B0054D4271E99389EBE4B136B0819DE1F150BA0FF9D7",
                    new DeviceInfo(DEVICE_PIXEL_6, 100, 100, false, true, OS_STOCK))
            .put("42ED1BCA352FABD428F34E8FCEE62776F4CB2C66E06F82E5A59FF4495267BFC2",
                    new DeviceInfo(DEVICE_PIXEL_6_PRO, 100, 100, false, true, OS_STOCK))
            .put("9AC4174153D45E4545B0F49E22FE63273999B6AC1CB6949C3A9F03EC8807EEE9",
                    new DeviceInfo(DEVICE_PIXEL_6A, 100, 100, false, true, OS_STOCK))
            .put("8B2C4CD539F5075E8E7CF212ADB3DB0413FBD77D321199C73D5A473C51F2E10D",
                    new DeviceInfo(DEVICE_PIXEL_7, 100, 100, false, true, OS_STOCK))
            .put("26AC4C60BEB1E378357CAD0C3061347AF8DF6FBABBB0D8CEA2445855EE01E368",
                    new DeviceInfo(DEVICE_PIXEL_7_PRO, 100, 100, false, true, OS_STOCK))
            .put("003F1ADE9D476E612B00F2983E6AD7DCD15E6A80CC2DBB008DA7D6839ED73A8F",
                    new DeviceInfo(DEVICE_PIXEL_7A, 100, 100, false, true, OS_STOCK))
            .put("C72E569827EC2E19A1073D927E3B6A1C6C8322DA795D5CE44BF3B95031B37C0A",
                    new DeviceInfo(DEVICE_PIXEL_TABLET, 100, 100, false, true, OS_STOCK))
            .put("3BBD4712D8714812E762D3FB6D2D5724800C3342B1835CDBC1D3634AE59D646E",
                    new DeviceInfo(DEVICE_PIXEL_FOLD, 100, 100, false, true, OS_STOCK))
            .put("64DEF0828FF5D3EAC65C3F5CEF46C1D855FE0A5D8525E90FB94FC3DBA9988C87",
                    new DeviceInfo(DEVICE_PIXEL_8, 300, 300, false, true, OS_STOCK))
            .put("E5362DDF4676E8AA134DB520749BCB1F44FE6556F5E7BFAB130CB6343476FC15",
                    new DeviceInfo(DEVICE_PIXEL_8_PRO, 300, 300, false, true, OS_STOCK))
            .put("9DE25FB02BB5530D44149D148437C82E267E557322530AA6F03B0AC2E92931DA",
                    new DeviceInfo(DEVICE_PIXEL_8A, 300, 300, false, true, OS_STOCK))
            .put("ACB5A4DD184E2C44CFA6A53D2D5C5E8674C9498A59F8AE8019942AC1FCEB1E6C",
                    new DeviceInfo(DEVICE_PIXEL_9, 300, 300, false, true, OS_STOCK))
            .put("06035F636BDB7F299A94B51C7D5645A913551327FFC5452B00C5830476D3208E",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO, 300, 300, false, true, OS_STOCK))
            .put("D05975CFD778082E3D1623C91419F6D8634E579A786592118CCEA057537579B7",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_XL, 300, 300, false, true, OS_STOCK))
            .put("800E9093D29614F5BC3FC76A0E819BA0A5C0C94A7D6A17C53E7D017D346B7172",
                    new DeviceInfo(DEVICE_PIXEL_9_PRO_FOLD, 300, 300, false, true, OS_STOCK))
            .put("3327AF62D84AB897AF2523A16DCB5801E60C5D5B97F41CA1BD099C4784F7B743",
                    new DeviceInfo(DEVICE_PIXEL_9A, 300, 300, false, true, OS_STOCK))
            .build();

    private static final byte[] GOOGLE_ROOT_CERTIFICATE_0 = readResource("google_root_0.der");
    private static final byte[] GOOGLE_ROOT_CERTIFICATE_1 = readResource("google_root_1.der");
    private static final byte[] GOOGLE_ROOT_CERTIFICATE_2 = readResource("google_root_2.der");
    private static final byte[] GOOGLE_ROOT_CERTIFICATE_3 = readResource("google_root_3.der");
    static final byte[] DEFLATE_DICTIONARY_2 = readResource("deflate_dictionary_2.bin");
    static final byte[] DEFLATE_DICTIONARY_4 = readResource("deflate_dictionary_4.bin");

    private static byte[] readResource(final String path) {
        try (final InputStream stream = AttestationProtocol.class.getResourceAsStream(path)) {
            return stream.readAllBytes();
        } catch (final IOException e) {
            throw new RuntimeException(e);
        }
    }

    private static final ThreadLocal<SecureRandom> random =
            ThreadLocal.withInitial(() -> new SecureRandom());

    static byte[] generateRandomToken() {
        final byte[] challenge = new byte[RANDOM_TOKEN_LENGTH];
        random.get().nextBytes(challenge);
        return challenge;
    }

    private static byte[] getFingerprint(final Certificate certificate)
            throws CertificateEncodingException {
        return FINGERPRINT_HASH_FUNCTION.hashBytes(certificate.getEncoded()).asBytes();
    }

    private record Verified(String device, String verifiedBootKey, byte[] verifiedBootHash,
            String osName, int osVersion, int osPatchLevel, int vendorPatchLevel, int bootPatchLevel,
            int appVersion, int appVariant, int securityLevel, boolean attestKey) {

        boolean hasPogoPins() {
            return DEVICE_PIXEL_TABLET.equals(device);
        }
    }

    private static X509Certificate generateCertificate(final InputStream in)
            throws CertificateException {
        return (X509Certificate) CertificateFactory.getInstance("X.509").generateCertificate(in);
    }

    private static Verified verifyStateless(final Certificate[] certificates,
            final Cache<ByteBuffer, Boolean> pendingChallenges, final boolean hasPersistentKey,
            final byte[][] validRoots) throws GeneralSecurityException {

        verifyCertificateSignatures(certificates, hasPersistentKey);

        // check that the root certificate is a valid key attestation root
        final byte[] root = certificates[certificates.length - 1].getEncoded();
        if (!Arrays.stream(validRoots).anyMatch(v -> Arrays.equals(v, root))) {
            throw new GeneralSecurityException("root certificate is not a valid key attestation root");
        }

        final ParsedAttestationRecord attestation;
        try {
            attestation = ParsedAttestationRecord.createParsedAttestationRecord(
                    List.of((X509Certificate) certificates[0]));
        } catch (final IOException | ParsedAttestationRecord.KeyDescriptionMissingException e) {
            throw new GeneralSecurityException(e);
        }

        final ParsedAttestationRecord.SecurityLevel attestationSecurityLevelEnum = attestation.attestationSecurityLevel;

        // enforce hardware-based attestation
        if (attestationSecurityLevelEnum != ParsedAttestationRecord.SecurityLevel.TRUSTED_ENVIRONMENT &&
                attestationSecurityLevelEnum != ParsedAttestationRecord.SecurityLevel.STRONG_BOX) {
            throw new GeneralSecurityException("attestation security level is not valid");
        }
        if (attestation.keymasterSecurityLevel != attestationSecurityLevelEnum) {
            throw new GeneralSecurityException("keymaster security level does not match attestation security level");
        }

        // prevent replay attacks
        final byte[] challenge = attestation.attestationChallenge;
        if (pendingChallenges.asMap().remove(ByteBuffer.wrap(challenge)) == null) {
            throw new GeneralSecurityException("challenge not pending");
        }

        // enforce communicating with the Auditor app via OS level security
        final AuthorizationList softwareEnforced = attestation.softwareEnforced;
        final AttestationApplicationId attestationApplicationId = softwareEnforced.attestationApplicationId
                .orElseThrow(() -> new GeneralSecurityException("key has no applicationId supplied"));
        final List<AttestationPackageInfo> infos = attestationApplicationId.packageInfos;
        if (infos.size() != 1) {
            throw new GeneralSecurityException("invalid number of attestation packages");
        }
        final AttestationPackageInfo info = infos.get(0);
        final List<byte[]> signatureDigests = attestationApplicationId.signatureDigests;
        if (signatureDigests.size() == 0) {
            throw new GeneralSecurityException("Auditor signing keys are missing from the attestation data.\n\nThis is known to happen after a system_server crash causes a soft reboot, which can be resolved by a full reboot of the device.");
        } else if (signatureDigests.size() != 1) {
            throw new GeneralSecurityException("invalid number of Auditor app signing keys: " + signatureDigests.size());
        }
        final String signatureDigest = BaseEncoding.base16().encode(signatureDigests.get(0));
        final byte appVariant;
        final String packageName = info.packageName;
        if (AUDITOR_APP_PACKAGE_NAME_RELEASE.equals(packageName)) {
            if (!AUDITOR_APP_SIGNATURE_DIGEST_RELEASE.equals(signatureDigest)) {
                throw new GeneralSecurityException("invalid Auditor app signing key");
            }
            appVariant = AUDITOR_APP_VARIANT_RELEASE;
        } else if (AUDITOR_APP_PACKAGE_NAME_PLAY.equals(packageName)) {
            if (!AUDITOR_APP_SIGNATURE_DIGEST_PLAY.equals(signatureDigest)) {
                throw new GeneralSecurityException("invalid Auditor app signing key");
            }
            appVariant = AUDITOR_APP_VARIANT_PLAY;
        } else if (AUDITOR_APP_PACKAGE_NAME_DEBUG.equals(packageName)) {
            if (!BuildConfig.DEBUG) {
                throw new GeneralSecurityException("Auditor debug builds are only trusted by other Auditor debug builds");
            }
            if (!AUDITOR_APP_SIGNATURE_DIGEST_DEBUG.equals(signatureDigest)) {
                throw new GeneralSecurityException("invalid Auditor app signing key");
            }
            appVariant = AUDITOR_APP_VARIANT_DEBUG;
        } else {
            throw new GeneralSecurityException("invalid Auditor app package name: " + packageName);
        }
        final int appVersion = Math.toIntExact(info.version); // int for compatibility
        if (appVersion < AUDITOR_APP_MINIMUM_VERSION) {
            throw new GeneralSecurityException("Auditor app is too old: " + appVersion);
        }

        final AuthorizationList teeEnforced = attestation.teeEnforced;

        // verified boot security checks
        final RootOfTrust rootOfTrust = teeEnforced.rootOfTrust.orElse(null);
        if (rootOfTrust == null) {
            throw new GeneralSecurityException("missing root of trust");
        }
        if (!rootOfTrust.deviceLocked) {
            throw new GeneralSecurityException("device is not locked");
        }
        final RootOfTrust.VerifiedBootState verifiedBootState = rootOfTrust.verifiedBootState;
        final String verifiedBootKey = BaseEncoding.base16().encode(rootOfTrust.verifiedBootKey);
        final DeviceInfo device;
        if (verifiedBootState == RootOfTrust.VerifiedBootState.SELF_SIGNED) {
            if (attestationSecurityLevelEnum == ParsedAttestationRecord.SecurityLevel.STRONG_BOX) {
                device = fingerprintsStrongBoxCustomOS.get(verifiedBootKey);
            } else {
                device = fingerprintsCustomOS.get(verifiedBootKey);
            }
        } else if (verifiedBootState == RootOfTrust.VerifiedBootState.VERIFIED) {
            if (attestationSecurityLevelEnum == ParsedAttestationRecord.SecurityLevel.STRONG_BOX) {
                device = fingerprintsStrongBoxStock.get(verifiedBootKey);
            } else {
                device = fingerprintsStock.get(verifiedBootKey);
            }
        } else {
            throw new GeneralSecurityException("verified boot state is not verified or self signed");
        }

        if (device == null) {
            throw new GeneralSecurityException("invalid verified boot key fingerprint: " + verifiedBootKey);
        }

        // enforce StrongBox for new pairings with devices supporting it
        if (!hasPersistentKey && device.enforceStrongBox &&
                attestationSecurityLevelEnum != ParsedAttestationRecord.SecurityLevel.STRONG_BOX) {
            throw new GeneralSecurityException("non-StrongBox security level for device supporting it");
        }

        // OS version sanity checks
        final int osVersion = teeEnforced.osVersion.orElse(0);
        if (osVersion < OS_VERSION_MINIMUM) {
            throw new GeneralSecurityException("OS version too old: " + osVersion);
        }
        final int osPatchLevel = teeEnforced.osPatchLevel.orElse(0);
        if (osPatchLevel < OS_PATCH_LEVEL_MINIMUM) {
            throw new GeneralSecurityException("OS patch level too old: " + osPatchLevel);
        }
        final int vendorPatchLevel = teeEnforced.vendorPatchLevel.orElse(0);
        if (vendorPatchLevel < VENDOR_PATCH_LEVEL_MINIMUM) {
            throw new GeneralSecurityException("Vendor patch level too old: " + vendorPatchLevel);
        }
        final int bootPatchLevel = teeEnforced.bootPatchLevel.orElse(0);
        if (bootPatchLevel < BOOT_PATCH_LEVEL_MINIMUM) {
            throw new GeneralSecurityException("Boot patch level too old: " + bootPatchLevel);
        }

        // key sanity checks
        if (!teeEnforced.purpose.equals(
                ImmutableSet.of(AuthorizationList.OperationPurpose.SIGN, AuthorizationList.OperationPurpose.VERIFY))) {
            throw new GeneralSecurityException("key has invalid purposes");
        }
        if (teeEnforced.origin.orElseThrow(() -> new GeneralSecurityException("key has missing origin")) != AuthorizationList.KeyOrigin.GENERATED) {
            throw new GeneralSecurityException("key not origin generated");
        }
        if (teeEnforced.allApplications) {
            throw new GeneralSecurityException("expected key only usable by Auditor app");
        }
        if (device.rollbackResistant && !teeEnforced.rollbackResistant) {
            throw new GeneralSecurityException("expected rollback resistant key");
        }

        // version sanity checks
        final int attestationVersion = attestation.attestationVersion;
        if (attestationVersion < device.attestationVersion) {
            throw new GeneralSecurityException("attestation version " + attestationVersion + " below " + device.attestationVersion);
        }
        final int keymasterVersion = attestation.keymasterVersion;
        if (keymasterVersion < device.keymasterVersion) {
            throw new GeneralSecurityException("keymaster version " + keymasterVersion + " below " + device.keymasterVersion);
        }

        final byte[] verifiedBootHash = rootOfTrust.verifiedBootHash.orElse(null);
        if (attestationVersion >= 3 && verifiedBootHash == null) {
            throw new GeneralSecurityException("verifiedBootHash expected for attestation version >= 3");
        }

        boolean attestKey = false;
        try {
            final ParsedAttestationRecord attestation1 = ParsedAttestationRecord.createParsedAttestationRecord(
                    List.of((X509Certificate) certificates[1]));

            if (attestation1.attestationSecurityLevel != attestation.attestationSecurityLevel) {
                throw new GeneralSecurityException("attest key attestation security level does not match");
            }

            if (attestation1.keymasterSecurityLevel != attestation.keymasterSecurityLevel) {
                throw new GeneralSecurityException("attest key keymaster security level does not match");
            }

            final AuthorizationList teeEnforced1 = attestation1.teeEnforced;

            // verified boot security checks
            final RootOfTrust rootOfTrust1 = teeEnforced1.rootOfTrust.orElse(null);
            if (rootOfTrust1 == null) {
                throw new GeneralSecurityException("attest key missing root of trust");
            }
            if (rootOfTrust1.deviceLocked != rootOfTrust.deviceLocked) {
                throw new GeneralSecurityException("attest key lock state does not match");
            }
            if (rootOfTrust1.verifiedBootState != rootOfTrust.verifiedBootState) {
                throw new GeneralSecurityException("attest key verified boot state does not match");
            }
            if (!Arrays.equals(rootOfTrust1.verifiedBootKey, rootOfTrust.verifiedBootKey)) {
                throw new GeneralSecurityException("attest key verified boot key does not match");
            }

            // key sanity checks
            if (!teeEnforced1.purpose.equals(ImmutableSet.of(AuthorizationList.OperationPurpose.ATTEST_KEY))) {
                throw new GeneralSecurityException("attest key has invalid purposes");
            }
            if (teeEnforced1.origin.orElse(null) != AuthorizationList.KeyOrigin.GENERATED) {
                throw new GeneralSecurityException("attest key not origin generated");
            }
            if (teeEnforced1.allApplications) {
                throw new GeneralSecurityException("expected attest key only usable by Auditor app");
            }
            if (device.rollbackResistant && !teeEnforced1.rollbackResistant) {
                throw new GeneralSecurityException("expected rollback resistant attest key");
            }

            if (!hasPersistentKey) {
                if (!Arrays.equals(attestation1.attestationChallenge, attestation.attestationChallenge)) {
                    throw new GeneralSecurityException("attest key challenge does not match");
                }

                if (!attestation1.softwareEnforced.attestationApplicationId.orElseThrow(() ->
                        new GeneralSecurityException("missing attest key application")).equals(attestationApplicationId)) {
                    throw new GeneralSecurityException("attest key application does not match");
                }

                // version sanity checks
                if (attestation1.attestationVersion != attestation.attestationVersion) {
                    throw new GeneralSecurityException("attest key attestation version does not match");
                }
                if (attestation1.keymasterVersion != attestation.keymasterVersion) {
                    throw new GeneralSecurityException("attest key keymaster version does not match");
                }

                // OS version sanity checks
                if (!teeEnforced1.osVersion.equals(teeEnforced.osVersion)) {
                    throw new GeneralSecurityException("attest key OS version does not match");
                }
                if (!teeEnforced1.osPatchLevel.equals(teeEnforced.osPatchLevel)) {
                    throw new GeneralSecurityException("attest key OS patch level does not match");
                }
                if (!teeEnforced1.vendorPatchLevel.equals(teeEnforced.vendorPatchLevel)) {
                    throw new GeneralSecurityException("attest key vendor patch level does not match");
                }
                if (!teeEnforced1.bootPatchLevel.equals(teeEnforced.bootPatchLevel)) {
                    throw new GeneralSecurityException("attest key boot patch level does not match");
                }

                if (!Arrays.equals(rootOfTrust1.verifiedBootHash.orElse(new byte[0]), rootOfTrust.verifiedBootHash.orElse(new byte[0]))) {
                    throw new GeneralSecurityException("attest key verified boot hash does not match");
                }
            }

            attestKey = true;
        } catch (final IOException e) {
            throw new GeneralSecurityException(e);
        } catch (final ParsedAttestationRecord.KeyDescriptionMissingException ignored) {}

        // enforce attest key for new pairings with devices supporting it
        if (!hasPersistentKey && attestationVersion >= 100 && !attestKey) {
            throw new GeneralSecurityException("missing per-pairing attest key for device supporting it");
        }

        for (int i = 2; i < certificates.length; i++) {
            try {
                ParsedAttestationRecord.createParsedAttestationRecord(List.of((X509Certificate) certificates[i]));
            } catch (final IOException e) {
                throw new GeneralSecurityException(e);
            } catch (final ParsedAttestationRecord.KeyDescriptionMissingException e) {
                continue;
            }
            throw new GeneralSecurityException("only initial key and attest key should have attestation extension");
        }

        return new Verified(device.name, verifiedBootKey, verifiedBootHash, device.osName,
                osVersion, osPatchLevel, vendorPatchLevel, bootPatchLevel, appVersion, appVariant,
                ParsedAttestationRecord.securityLevelToInt(attestationSecurityLevelEnum), attestKey);
    }

    // Only checks expiry beyond the initial certificate for the initial pairing since the
    // certificates are short lived when remote provisioning is in use and we prevent rotation by
    // using the attest key feature to provide permanent pairing-specific certificate chains in
    // order to pin them.
    private static void verifyCertificateSignatures(final Certificate[] certChain, final boolean hasPersistentKey)
            throws GeneralSecurityException {
        for (int i = 1; i < certChain.length; ++i) {
            try {
                if (i == 1 || !hasPersistentKey) {
                    ((X509Certificate) certChain[i - 1]).checkValidity();
                }
                certChain[i - 1].verify(certChain[i].getPublicKey());
            } catch (final GeneralSecurityException e) {
                throw new GeneralSecurityException("Failed to verify certificate "
                        + certChain[i - 1] + " with public key " + certChain[i].getPublicKey(), e);
            }
        }

        // Last cert is self-signed.
        final int i = certChain.length - 1;
        try {
            if (i == 0 || !hasPersistentKey) {
                ((X509Certificate) certChain[i]).checkValidity();
            }
            certChain[i].verify(certChain[i].getPublicKey());
        } catch (CertificateException e) {
            throw new GeneralSecurityException(
                    "Root cert " + certChain[i] + " is not correctly self-signed", e);
        }
    }

    private static String formatPatchLevel(final int patchLevel) {
        final String s = Integer.toString(patchLevel);
        return s.substring(0, 4) + "-" + s.substring(4, 6) +
                (s.length() >= 8 ? "-" + s.substring(6, 8) : "");
    }

    private static void verifySignature(final PublicKey key, final ByteBuffer message,
            final byte[] signature) throws GeneralSecurityException {
        final Signature sig = Signature.getInstance(SIGNATURE_ALGORITHM);
        sig.initVerify(key);
        sig.update(message);
        if (!sig.verify(signature)) {
            throw new GeneralSecurityException("signature verification failed");
        }
    }

    private static String toYesNoString(final boolean value) {
        return value ? "yes" : "no";
    }

    record SecurityStateExt(
            int autoRebootSeconds, byte portSecurityMode, byte userCount, byte oemUnlocked) {
        static final int UNKNOWN_VALUE = -1;
        static final SecurityStateExt UNKNOWN = new SecurityStateExt(UNKNOWN_VALUE,
                (byte) UNKNOWN_VALUE, (byte) UNKNOWN_VALUE, (byte) UNKNOWN_VALUE);
    }

    private static void verify(final byte[] fingerprint,
            final Cache<ByteBuffer, Boolean> pendingChallenges, final long userId,
            final boolean paired, final ByteBuffer signedMessage, final byte[] signature,
            final Certificate[] attestationCertificates, final boolean userProfileSecure,
            final boolean accessibility, final boolean deviceAdmin,
            final boolean deviceAdminNonSystem, final boolean adbEnabled,
            final boolean addUsersWhenLocked, final boolean enrolledBiometrics,
            final boolean systemUser, final SecurityStateExt securityStateExt)
            throws GeneralSecurityException, IOException, SQLiteException {
        final String fingerprintHex = BaseEncoding.base16().encode(fingerprint);
        final byte[] currentFingerprint = getFingerprint(attestationCertificates[0]);
        final boolean hasPersistentKey = !Arrays.equals(currentFingerprint, fingerprint);
        if (paired && !hasPersistentKey) {
            throw new GeneralSecurityException("must be authenticated with subscribeKey for initial verification");
        }

        final SQLiteConnection conn = AttestationServer.getLocalAttestationConn();
        try {
            conn.exec("BEGIN IMMEDIATE TRANSACTION");

            Certificate[] pinnedCertificates = null;
            byte[] pinnedVerifiedBootKey = null;
            int pinnedOsVersion = Integer.MAX_VALUE;
            int pinnedOsPatchLevel = Integer.MAX_VALUE;
            int pinnedVendorPatchLevel = 0;
            int pinnedBootPatchLevel = 0;
            int pinnedAppVersion = Integer.MAX_VALUE;
            int pinnedAppVariant = 0;
            int pinnedSecurityLevel = 1;
            if (hasPersistentKey) {
                final SQLiteStatement st = conn.prepare("""
                        SELECT
                            pinnedCertificates,
                            pinnedVerifiedBootKey,
                            pinnedOsVersion,
                            pinnedOsPatchLevel,
                            pinnedVendorPatchLevel,
                            pinnedBootPatchLevel,
                            pinnedAppVersion,
                            pinnedAppVariant,
                            pinnedSecurityLevel,
                            userId
                        FROM Devices WHERE fingerprint = ?""");
                try {
                    st.bind(1, fingerprint);
                    if (st.step()) {
                        try {
                            pinnedCertificates = decodeChain(DEFLATE_DICTIONARY_4, st.columnBlob(0));
                        } catch (final DataFormatException e) {
                            throw new IOException(e);
                        }
                        pinnedVerifiedBootKey = st.columnBlob(1);
                        pinnedOsVersion = st.columnInt(2);
                        pinnedOsPatchLevel = st.columnInt(3);
                        pinnedVendorPatchLevel = st.columnInt(4);
                        pinnedBootPatchLevel = st.columnInt(5);
                        pinnedAppVersion = st.columnInt(6);
                        pinnedAppVariant = st.columnInt(7);
                        pinnedSecurityLevel = st.columnInt(8);
                        if (userId != st.columnLong(9)) {
                            throw new GeneralSecurityException("wrong userId");
                        }
                    } else {
                        throw new GeneralSecurityException(
                                "Pairing data for this Auditee is missing. Cannot perform paired attestation.\n" +
                                "\nEither the initial pairing was incomplete or the device is compromised.\n" +
                                "\nIf the initial pairing was simply not completed, clear the pairing data on either the Auditee or the Auditor via the menu and try again.\n");
                    }
                } finally {
                    st.dispose();
                }
            }

            final Verified verified = verifyStateless(attestationCertificates, pendingChallenges, hasPersistentKey,
                    new byte[][]{GOOGLE_ROOT_CERTIFICATE_0, GOOGLE_ROOT_CERTIFICATE_1,
                        GOOGLE_ROOT_CERTIFICATE_2, GOOGLE_ROOT_CERTIFICATE_3});
            final byte[] verifiedBootKey = BaseEncoding.base16().decode(verified.verifiedBootKey);

            final long now = System.currentTimeMillis();

            if (hasPersistentKey) {
                final int chainOffset;
                final int pinOffset;
                if (attestationCertificates.length != pinnedCertificates.length) {
                    if (attestationCertificates.length == 5 && pinnedCertificates.length == 4) {
                        // backwards compatible use of attest key without the security benefits for
                        // forward compatibility with remote provisioning
                        chainOffset = 1;
                    } else {
                        throw new GeneralSecurityException("certificate chain length mismatch");
                    }
                } else {
                    chainOffset = 0;
                }
                for (int i = 1 + chainOffset; i < attestationCertificates.length; i++) {
                    if (!Arrays.equals(attestationCertificates[i].getEncoded(), pinnedCertificates[i - chainOffset].getEncoded())) {
                        throw new GeneralSecurityException("certificate chain mismatch");
                    }
                }

                final Certificate persistentCertificate = pinnedCertificates[0];
                if (!Arrays.equals(fingerprint, getFingerprint(persistentCertificate))) {
                    throw new GeneralSecurityException("corrupt Auditor pinning data");
                }
                verifySignature(persistentCertificate.getPublicKey(), signedMessage, signature);

                if (!Arrays.equals(verifiedBootKey, pinnedVerifiedBootKey)) {
                    throw new GeneralSecurityException("pinned verified boot key mismatch");
                }
                if (verified.osVersion < pinnedOsVersion) {
                    throw new GeneralSecurityException("OS version downgrade detected");
                }
                if (verified.osPatchLevel < pinnedOsPatchLevel) {
                    throw new GeneralSecurityException("OS patch level downgrade detected");
                }
                if (verified.vendorPatchLevel < pinnedVendorPatchLevel) {
                    throw new GeneralSecurityException("Vendor patch level downgrade detected");
                }
                if (verified.bootPatchLevel < pinnedBootPatchLevel) {
                    throw new GeneralSecurityException("Boot patch level downgrade detected");
                }
                if (verified.appVersion < pinnedAppVersion) {
                    throw new GeneralSecurityException("App version downgraded");
                }
                if (verified.securityLevel != pinnedSecurityLevel) {
                    throw new GeneralSecurityException("Security level mismatch");
                }

                final SQLiteStatement update = conn.prepare("""
                        UPDATE Devices SET
                            verifiedBootHash = ?,
                            pinnedOsVersion = ?,
                            pinnedOsPatchLevel = ?,
                            pinnedVendorPatchLevel = ?,
                            pinnedBootPatchLevel = ?,
                            pinnedAppVersion = ?,
                            pinnedSecurityLevel = ?,
                            userProfileSecure = ?,
                            enrolledBiometrics = ?,
                            accessibility = ?,
                            deviceAdmin = ?,
                            adbEnabled = ?,
                            addUsersWhenLocked = ?,
                            oemUnlockAllowed = ?,
                            systemUser = ?,
                            autoRebootSeconds = ?,
                            portSecurityMode = ?,
                            userCount = ?,
                            oemUnlockAllowed2 = ?,
                            verifiedTimeLast = ?
                        WHERE fingerprint = ?""");
                try {
                    update.bind(1, verified.verifiedBootHash);
                    update.bind(2, verified.osVersion);
                    update.bind(3, verified.osPatchLevel);
                    if (verified.vendorPatchLevel != 0) {
                        update.bind(4, verified.vendorPatchLevel);
                    }
                    if (verified.bootPatchLevel != 0) {
                        update.bind(5, verified.bootPatchLevel);
                    }
                    update.bind(6, verified.appVersion);
                    update.bind(7, verified.securityLevel);
                    update.bind(8, userProfileSecure ? 1 : 0);
                    update.bind(9, enrolledBiometrics ? 1 : 0);
                    update.bind(10, accessibility ? 1 : 0);
                    update.bind(11, deviceAdmin ? (deviceAdminNonSystem ? 2 : 1) : 0);
                    update.bind(12, adbEnabled ? 1 : 0);
                    update.bind(13, addUsersWhenLocked ? 1 : 0);
                    update.bind(14, 0); // oemUnlockAllowed
                    update.bind(15, systemUser ? 1 : 0);
                    update.bind(16, securityStateExt.autoRebootSeconds);
                    update.bind(17, securityStateExt.portSecurityMode);
                    update.bind(18, securityStateExt.userCount);
                    update.bind(19, securityStateExt.oemUnlocked);
                    update.bind(20, now);
                    update.bind(21, fingerprint);
                    update.step();
                } finally {
                    update.dispose();
                }
            } else {
                verifySignature(attestationCertificates[0].getPublicKey(), signedMessage, signature);

                final SQLiteStatement insert = conn.prepare("""
                        INSERT INTO Devices (
                            fingerprint,
                            pinnedCertificates,
                            attestKey,
                            pinnedVerifiedBootKey,
                            verifiedBootHash,
                            pinnedOsVersion,
                            pinnedOsPatchLevel,
                            pinnedVendorPatchLevel,
                            pinnedBootPatchLevel,
                            pinnedAppVersion,
                            pinnedAppVariant,
                            pinnedSecurityLevel,
                            userProfileSecure,
                            enrolledBiometrics,
                            accessibility,
                            deviceAdmin,
                            adbEnabled,
                            addUsersWhenLocked,
                            oemUnlockAllowed,
                            systemUser,
                            autoRebootSeconds,
                            portSecurityMode,
                            userCount,
                            oemUnlockAllowed2,
                            verifiedTimeFirst,
                            verifiedTimeLast,
                            userId
                        ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""");
                try {
                    insert.bind(1, fingerprint);
                    insert.bind(2, encodeChain(DEFLATE_DICTIONARY_4, attestationCertificates));
                    insert.bind(3, verified.attestKey ? 1 : 0);
                    insert.bind(4, verifiedBootKey);
                    insert.bind(5, verified.verifiedBootHash);
                    insert.bind(6, verified.osVersion);
                    insert.bind(7, verified.osPatchLevel);
                    if (verified.vendorPatchLevel != 0) {
                        insert.bind(8, verified.vendorPatchLevel);
                    }
                    if (verified.bootPatchLevel != 0) {
                        insert.bind(9, verified.bootPatchLevel);
                    }
                    insert.bind(10, verified.appVersion);
                    insert.bind(11, verified.appVariant);
                    insert.bind(12, verified.securityLevel);
                    insert.bind(13, userProfileSecure ? 1 : 0);
                    insert.bind(14, enrolledBiometrics ? 1 : 0);
                    insert.bind(15, accessibility ? 1 : 0);
                    insert.bind(16, deviceAdmin ? (deviceAdminNonSystem ? 2 : 1) : 0);
                    insert.bind(17, adbEnabled ? 1 : 0);
                    insert.bind(18, addUsersWhenLocked ? 1 : 0);
                    insert.bind(19, 0); // oemUnlockAllowed
                    insert.bind(20, systemUser ? 1 : 0);
                    insert.bind(21, securityStateExt.autoRebootSeconds);
                    insert.bind(22, securityStateExt.portSecurityMode);
                    insert.bind(23, securityStateExt.userCount);
                    insert.bind(24, securityStateExt.oemUnlocked);
                    insert.bind(25, now);
                    insert.bind(26, now);
                    insert.bind(27, userId);
                    insert.step();
                } finally {
                    insert.dispose();
                }
            }

            final SQLiteStatement insert = conn.prepare("""
                    INSERT INTO Attestations (
                        fingerprint,
                        time,
                        strong,
                        osVersion,
                        osPatchLevel,
                        vendorPatchLevel,
                        bootPatchLevel,
                        verifiedBootHash,
                        appVersion,
                        userProfileSecure,
                        enrolledBiometrics,
                        accessibility,
                        deviceAdmin,
                        adbEnabled,
                        addUsersWhenLocked,
                        oemUnlockAllowed,
                        systemUser,
                        autoRebootSeconds,
                        portSecurityMode,
                        userCount,
                        oemUnlockAllowed2
                    ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)""");
            try {
                insert.bind(1, fingerprint);
                insert.bind(2, now);
                insert.bind(3, hasPersistentKey ? 1 : 0);
                insert.bind(4, verified.osVersion);
                insert.bind(5, verified.osPatchLevel);
                if (verified.vendorPatchLevel != 0) {
                    insert.bind(6, verified.vendorPatchLevel);
                }
                if (verified.bootPatchLevel != 0) {
                    insert.bind(7, verified.bootPatchLevel);
                }
                insert.bind(8, verified.verifiedBootHash);
                insert.bind(9, verified.appVersion);
                insert.bind(10, userProfileSecure ? 1 : 0);
                insert.bind(11, enrolledBiometrics ? 1 : 0);
                insert.bind(12, accessibility ? 1 : 0);
                insert.bind(13, deviceAdmin ? (deviceAdminNonSystem ? 2 : 1) : 0);
                insert.bind(14, adbEnabled ? 1 : 0);
                insert.bind(15, addUsersWhenLocked ? 1 : 0);
                insert.bind(16, 0); // oemUnlockAllowed
                insert.bind(17, systemUser ? 1 : 0);
                insert.bind(18, securityStateExt.autoRebootSeconds);
                insert.bind(19, securityStateExt.portSecurityMode);
                insert.bind(20, securityStateExt.userCount);
                insert.bind(21, securityStateExt.oemUnlocked);

                insert.step();
            } finally {
                insert.dispose();
            }

            conn.exec("COMMIT TRANSACTION");
        } finally {
            AttestationServer.rollbackIfNeeded(conn);
        }
    }

    static Certificate[] decodeChain(final byte[] dictionary, final byte[] compressedChain)
            throws DataFormatException, GeneralSecurityException {
        final byte[] chain = new byte[MAX_ENCODED_CHAIN_LENGTH];
        final Inflater inflater = new Inflater(true);
        inflater.setInput(compressedChain);
        inflater.setDictionary(dictionary);
        final int chainLength = inflater.inflate(chain);
        if (!inflater.finished()) {
            throw new GeneralSecurityException("certificate chain is too large");
        }
        inflater.end();

        final ByteBuffer chainDeserializer = ByteBuffer.wrap(chain, 0, chainLength);
        final List<Certificate> certs = new ArrayList<>();
        while (chainDeserializer.hasRemaining()) {
            final short encodedLength = chainDeserializer.getShort();
            final byte[] encoded = new byte[encodedLength];
            chainDeserializer.get(encoded);
            certs.add(generateCertificate(new ByteArrayInputStream(encoded)));
        }
        return certs.toArray(new Certificate[0]);
    }

    static byte[] encodeChain(final byte[] dictionary, final Certificate[] certificates)
            throws CertificateEncodingException, IOException {
        final ByteBuffer chainSerializer = ByteBuffer.allocate(MAX_ENCODED_CHAIN_LENGTH);
        for (int i = 0; i < certificates.length; i++) {
            final byte[] encoded = certificates[i].getEncoded();
            if (encoded.length > Short.MAX_VALUE) {
                throw new RuntimeException("encoded certificate too long");
            }
            chainSerializer.putShort((short) encoded.length);
            chainSerializer.put(encoded);
        }
        chainSerializer.flip();
        final byte[] chain = new byte[chainSerializer.remaining()];
        chainSerializer.get(chain);

        if (chain.length > MAX_ENCODED_CHAIN_LENGTH) {
            throw new RuntimeException("encoded certificate chain too long");
        }

        final ByteArrayOutputStream byteStream = new ByteArrayOutputStream();
        final Deflater deflater = new Deflater(Deflater.BEST_COMPRESSION, true);
        deflater.setDictionary(dictionary);
        final DeflaterOutputStream deflaterStream = new DeflaterOutputStream(byteStream, deflater);
        deflaterStream.write(chain);
        deflaterStream.finish();
        final byte[] compressed = byteStream.toByteArray();

        return compressed;
    }

    static void verifySerialized(final byte[] attestationResult,
            final Cache<ByteBuffer, Boolean> pendingChallenges, final long userId, final boolean paired)
            throws DataFormatException, GeneralSecurityException, IOException, SQLiteException {
        final ByteBuffer deserializer = ByteBuffer.wrap(attestationResult);
        final byte version = deserializer.get();
        if (version > PROTOCOL_VERSION) {
            throw new GeneralSecurityException("invalid protocol version: " + version);
        } else if (version < PROTOCOL_VERSION_MINIMUM) {
            throw new GeneralSecurityException("Auditee protocol version too old: " + version);
        }

        final short compressedChainLength = deserializer.getShort();
        final byte[] compressedChain = new byte[compressedChainLength];
        deserializer.get(compressedChain);

        final byte[] dictionary = DEFLATE_DICTIONARY_4;
        final Certificate[] certificates = decodeChain(dictionary, compressedChain);

        final byte[] fingerprint = new byte[FINGERPRINT_LENGTH];
        deserializer.get(fingerprint);

        final int osEnforcedFlags = deserializer.getInt();
        if ((osEnforcedFlags & ~OS_ENFORCED_FLAGS_ALL) != 0) {
            logger.info("unknown OS enforced flag set (flags: " + Integer.toBinaryString(osEnforcedFlags) + ")");
        }
        final boolean userProfileSecure = (osEnforcedFlags & OS_ENFORCED_FLAGS_USER_PROFILE_SECURE) != 0;
        final boolean accessibility = (osEnforcedFlags & OS_ENFORCED_FLAGS_ACCESSIBILITY) != 0;
        final boolean deviceAdmin = (osEnforcedFlags & OS_ENFORCED_FLAGS_DEVICE_ADMIN) != 0;
        final boolean deviceAdminNonSystem = (osEnforcedFlags & OS_ENFORCED_FLAGS_DEVICE_ADMIN_NON_SYSTEM) != 0;
        final boolean adbEnabled = (osEnforcedFlags & OS_ENFORCED_FLAGS_ADB_ENABLED) != 0;
        final boolean addUsersWhenLocked = (osEnforcedFlags & OS_ENFORCED_FLAGS_ADD_USERS_WHEN_LOCKED) != 0;
        final boolean enrolledBiometrics = (osEnforcedFlags & OS_ENFORCED_FLAGS_ENROLLED_BIOMETRICS) != 0;
        final boolean systemUser = (osEnforcedFlags & OS_ENFORCED_FLAGS_SYSTEM_USER) != 0;

        if (deviceAdminNonSystem && !deviceAdmin) {
            throw new GeneralSecurityException("invalid device administrator state");
        }

        SecurityStateExt securityStateExt;
        if (version >= 6) {
            final int autoRebootSeconds = deserializer.getInt();
            final byte portSecurityMode = deserializer.get();
            final byte userCount = deserializer.get();
            final byte oemUnlockAllowed = deserializer.get();
            securityStateExt = new SecurityStateExt(autoRebootSeconds, portSecurityMode,
                    userCount, oemUnlockAllowed);
        } else {
            securityStateExt = SecurityStateExt.UNKNOWN;
        }

        final int signatureLength = deserializer.remaining();
        final byte[] signature = new byte[signatureLength];
        deserializer.get(signature);

        deserializer.rewind();
        deserializer.limit(deserializer.capacity() - signature.length);

        verify(fingerprint, pendingChallenges, userId, paired, deserializer.asReadOnlyBuffer(), signature,
                certificates, userProfileSecure, accessibility, deviceAdmin, deviceAdminNonSystem,
                adbEnabled, addUsersWhenLocked, enrolledBiometrics, systemUser, securityStateExt);
    }
}
